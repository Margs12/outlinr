<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>sguesser — tests</title>
  <style>
    body   { font-family: monospace; padding: 2rem; background: #0f0f1a; color: #c8cedf; line-height: 1.7; }
    h1     { color: #7b8ab8; margin-bottom: 0.25rem; }
    p.meta { color: #3e4a68; font-size: 0.85rem; margin-bottom: 2rem; }
    .suite { margin-top: 1.5rem; color: #4a5a9a; font-weight: bold; font-size: 0.9rem; letter-spacing: 0.08em; }
    .pass  { color: #48bb78; }
    .fail  { color: #e05555; font-weight: bold; }
    #summary { margin-top: 2rem; padding-top: 1rem; border-top: 1px solid #1e2a40; font-size: 1rem; }
  </style>
</head>
<body>
  <h1>sguesser — test suite</h1>
  <p class="meta">Open browser console for stack traces on failures.</p>
  <div id="results"></div>
  <div id="summary"></div>

  <script type="module">
    import { normalise, matches, shuffle, escapeHtml } from './src/utils.js';
    import { featureToSvgPath, keepLargestPolygon, loadCountries } from './src/data.js';
    import { isValidMode, getCountryPool, classifyCorrectGuess, nextMode, MODE_ORDER,
             getEndlessWeights, drawEndlessCountry,
             getActiveTier, ENDLESS_TIER_CUTOFFS } from './src/gameState.js';
    import {
      PLAYER_KEY, SCORES_KEY, MAX_SCORES,
      getPlayerName, setPlayerName, addScore, getLeaderboard,
      _loadScores, _compareScores,
    } from './src/storage.js';

    // ── Minimal test harness ───────────────────────────────────────────────────

    const out     = document.getElementById('results');
    const sumEl   = document.getElementById('summary');
    let passed = 0, failed = 0;

    function suite(name) {
      const el = document.createElement('div');
      el.className = 'suite';
      el.textContent = `▸ ${name}`;
      out.appendChild(el);
    }

    function test(desc, fn) {
      const el = document.createElement('div');
      try {
        fn();
        passed++;
        el.className = 'pass';
        el.textContent = `  ✓ ${desc}`;
      } catch (err) {
        failed++;
        el.className = 'fail';
        el.textContent = `  ✗ ${desc}  —  ${err.message}`;
        console.error(desc, err);
      }
      out.appendChild(el);
    }

    function assert(condition, msg) {
      if (!condition) throw new Error(msg ?? 'assertion failed');
    }

    function assertEqual(a, b, msg) {
      if (a !== b) throw new Error(msg ?? `expected ${JSON.stringify(b)}, got ${JSON.stringify(a)}`);
    }

    // ── Helpers ────────────────────────────────────────────────────────────────

    function polygon(coords) {
      return { id: '1', geometry: { type: 'Polygon', coordinates: [coords] } };
    }

    function multiPolygon(polygons) {
      return { id: '1', geometry: { type: 'MultiPolygon', coordinates: polygons.map(c => [c]) } };
    }

    // Simple unit square: 0°–1° lon, 0°–1° lat
    const unitSquare = [
      [0, 0], [1, 0], [1, 1], [0, 1], [0, 0],
    ];

    // 10° × 10° box
    const bigBox = [
      [0, 0], [10, 0], [10, 10], [0, 10], [0, 0],
    ];

    // ── normalise() ────────────────────────────────────────────────────────────

    suite('normalise()');

    test('lowercases', () => assertEqual(normalise('ITALY'), 'italy'));
    test('trims leading/trailing spaces', () => assertEqual(normalise('  france  '), 'france'));
    test('collapses internal spaces', () => assertEqual(normalise('united  states'), 'united states'));
    test('strips acute accent', () => assertEqual(normalise('café'), 'cafe'));
    test('strips circumflex', () => assertEqual(normalise('côte'), 'cote'));
    test("handles full Ivory Coast alias", () => assertEqual(normalise("Côte D'Ivoire"), "cote d'ivoire"));
    test('handles São Tomé', () => assertEqual(normalise('São Tomé'), 'sao tome'));
    test('handles empty string', () => assertEqual(normalise(''), ''));
    test('handles already-normalised string', () => assertEqual(normalise('germany'), 'germany'));

    // ── matches() ─────────────────────────────────────────────────────────────

    suite('matches()');

    const italy  = { name: 'Italy',  aliases: ['italia'] };
    const usa    = { name: 'United States', aliases: ['usa', 'us', 'america', 'united states of america'] };
    const ivory  = { name: 'Ivory Coast', aliases: ["cote d'ivoire", "côte d'ivoire"] };
    const iran   = { name: 'Iran',   aliases: ['persia'] };
    const iraq   = { name: 'Iraq',   aliases: [] };
    const japan  = { name: 'Japan',  aliases: ['nippon', 'nihon'] };

    test('exact name match', () => assert(matches('Italy', italy)));
    test('case-insensitive name match', () => assert(matches('ITALY', italy)));
    test('alias match', () => assert(matches('italia', italy)));
    test('alias match case-insensitive', () => assert(matches('ITALIA', italy)));
    test('usa abbreviation', () => assert(matches('usa', usa)));
    test('full official name', () => assert(matches('United States of America', usa)));
    test('leading/trailing spaces', () => assert(matches('  Italy  ', italy)));
    test('diacritic alias', () => assert(matches("côte d'ivoire", ivory)));
    test('diacritic-free alias', () => assert(matches("cote d'ivoire", ivory)));
    test('alias with uppercase diacritic', () => assert(matches("Côte D'Ivoire", ivory)));
    test('Japan alias nippon', () => assert(matches('Nippon', japan)));
    test('Iran does NOT match Iraq', () => assert(!matches('Iran', iraq)));
    test('Iraq does NOT match Iran', () => assert(!matches('Iraq', iran)));
    test('wrong country returns false', () => assert(!matches('France', italy)));
    test('empty string returns false', () => assert(!matches('', italy)));
    test('partial match returns false', () => assert(!matches('Ital', italy)));

    // ── shuffle() ─────────────────────────────────────────────────────────────

    suite('shuffle()');

    test('returns same length', () => {
      const arr = [1, 2, 3, 4, 5];
      assertEqual(shuffle(arr).length, arr.length);
    });

    test('contains all original elements', () => {
      const arr = [1, 2, 3, 4, 5];
      const result = shuffle(arr).slice().sort((a, b) => a - b);
      assertEqual(JSON.stringify(result), JSON.stringify([1, 2, 3, 4, 5]));
    });

    test('does not mutate the input array', () => {
      const arr = [1, 2, 3];
      const copy = [...arr];
      shuffle(arr);
      assertEqual(JSON.stringify(arr), JSON.stringify(copy));
    });

    test('handles empty array', () => {
      assertEqual(shuffle([]).length, 0);
    });

    test('handles single-element array', () => {
      assertEqual(shuffle([42])[0], 42);
    });

    // ── featureToSvgPath() ─────────────────────────────────────────────────────

    suite('featureToSvgPath()');

    test('normal polygon returns non-empty path', () => {
      const path = featureToSvgPath(polygon(bigBox));
      assert(path.length > 0, 'expected non-empty path');
      assert(path.startsWith('M'), 'path should start with M');
      assert(path.endsWith('Z'), 'path should end with Z');
    });

    test('path contains only valid SVG path commands', () => {
      const path = featureToSvgPath(polygon(bigBox));
      assert(/^[ML\d\s.,Z-]+$/.test(path), 'unexpected characters in path');
    });

    test('lonRange > 180 returns empty string (antimeridian guard)', () => {
      const antimeridian = [
        [-170, 0], [170, 0], [170, 10], [-170, 10], [-170, 0],
      ];
      assertEqual(featureToSvgPath(polygon(antimeridian)), '');
    });

    test('extremely flat polygon (projH < 4 after aspect-ratio scaling) returns empty string', () => {
      // 150° wide × 2° tall at 30°N — cosine correction gives correctedLonRange ≈ 129°,
      // so scale = 170/129 ≈ 1.32, projH = 2 * 1.32 ≈ 2.6 → below the 4px guard.
      const extremelyFlat = [
        [0, 30], [150, 30], [150, 32], [0, 32], [0, 30],
      ];
      assertEqual(featureToSvgPath(polygon(extremelyFlat)), '');
    });

    test('MultiPolygon renders all sub-polygons (multiple M…Z segments)', () => {
      const path = featureToSvgPath(multiPolygon([bigBox, bigBox.map(([x, y]) => [x + 20, y + 20])]));
      const mCount = (path.match(/M/g) || []).length;
      assert(mCount >= 2, `expected at least 2 M commands, got ${mCount}`);
    });

    // ── keepLargestPolygon() ───────────────────────────────────────────────────

    suite('keepLargestPolygon()');

    const smallBox = [[0,0],[1,0],[1,1],[0,1],[0,0]];
    const largeBox = [[0,0],[20,0],[20,20],[0,20],[0,0]];

    test('Polygon feature is returned unchanged', () => {
      const feat = polygon(bigBox);
      const result = keepLargestPolygon(feat);
      assertEqual(result.geometry.type, 'Polygon');
      assertEqual(result.geometry.coordinates, feat.geometry.coordinates);
    });

    test('MultiPolygon: selects the larger polygon', () => {
      const feat   = multiPolygon([smallBox, largeBox]);
      const result = keepLargestPolygon(feat);
      assertEqual(result.geometry.type, 'Polygon');
      // The returned polygon's exterior ring should be largeBox
      assertEqual(JSON.stringify(result.geometry.coordinates[0]), JSON.stringify(largeBox));
    });

    test('MultiPolygon with one polygon returns that polygon', () => {
      const feat   = multiPolygon([bigBox]);
      const result = keepLargestPolygon(feat);
      assertEqual(result.geometry.type, 'Polygon');
    });

    test('original feature is not mutated', () => {
      const feat = multiPolygon([smallBox, largeBox]);
      const originalType = feat.geometry.type;
      keepLargestPolygon(feat);
      assertEqual(feat.geometry.type, originalType);
    });

    // ── testAsync helper ───────────────────────────────────────────────────────
    // Mirrors test() but supports async functions and awaits them before logging.

    async function testAsync(desc, fn) {
      const el = document.createElement('div');
      try {
        await fn();
        passed++;
        el.className = 'pass';
        el.textContent = `  ✓ ${desc}`;
      } catch (err) {
        failed++;
        el.className = 'fail';
        el.textContent = `  ✗ ${desc}  —  ${err.message}`;
        console.error(desc, err);
      }
      out.appendChild(el);
    }

    // ── matches() — edge cases (Issue 12) ─────────────────────────────────────

    suite('matches() — edge cases');

    const southKorea = { name: 'South Korea', aliases: ['korea', 'republic of korea', 'rok'] };
    const northKorea = { name: 'North Korea', aliases: ['dprk'] };

    test('"Korea" matches South Korea via alias', () =>
      assert(matches('Korea', southKorea)));
    test('"Korea" does NOT match North Korea', () =>
      assert(!matches('Korea', northKorea)));
    test('partial input "South" returns false (no substring matching)', () =>
      assert(!matches('South', southKorea)));
    test('whitespace-only input returns false', () =>
      assert(!matches('   ', italy)));

    // ── gameState helpers (Issues 9 & 10) ─────────────────────────────────────

    suite('isValidMode()');

    test('"easy" is valid',   () => assert(isValidMode('easy')));
    test('"medium" is valid', () => assert(isValidMode('medium')));
    test('"hard" is valid',   () => assert(isValidMode('hard')));
    test('"endless" is valid', () => assert(isValidMode('endless')));
    test('"extreme" is invalid', () => assert(!isValidMode('extreme')));
    test('undefined is invalid', () => assert(!isValidMode(undefined)));
    test('empty string is invalid', () => assert(!isValidMode('')));
    test('null is invalid', () => assert(!isValidMode(null)));

    suite('nextMode()');

    test('easy → medium', () => assertEqual(nextMode('easy'), 'medium'));
    test('medium → hard',  () => assertEqual(nextMode('medium'), 'hard'));
    test('hard → endless',  () => assertEqual(nextMode('hard'), 'endless'));
    test('endless → endless (clamps at end)', () => assertEqual(nextMode('endless'), 'endless'));
    test('MODE_ORDER has exactly 4 entries', () => assertEqual(MODE_ORDER.length, 4));
    test('MODE_ORDER starts with easy and ends with endless', () => {
      assertEqual(MODE_ORDER[0], 'easy');
      assertEqual(MODE_ORDER[MODE_ORDER.length - 1], 'endless');
    });

    suite('getCountryPool()');

    const sampleCountries = [
      { name: 'France',    tier: 'easy'   },
      { name: 'Germany',   tier: 'medium' },
      { name: 'Albania',   tier: 'hard'   },
      { name: 'Djibouti',  tier: 'expert' },
    ];

    test('easy mode returns only easy-tier countries', () => {
      const pool = getCountryPool(sampleCountries, 'easy');
      assertEqual(pool.length, 1);
      assert(pool.every(c => c.tier === 'easy'));
    });

    test('medium mode returns only medium-tier countries', () => {
      const pool = getCountryPool(sampleCountries, 'medium');
      assertEqual(pool.length, 1);
      assert(pool.every(c => c.tier === 'medium'));
    });

    test('hard mode returns only hard-tier countries', () => {
      const pool = getCountryPool(sampleCountries, 'hard');
      assertEqual(pool.length, 1);
      assert(pool.every(c => c.tier === 'hard'));
    });

    test('endless mode returns all countries regardless of tier', () => {
      const pool = getCountryPool(sampleCountries, 'endless');
      assertEqual(pool.length, sampleCountries.length);
    });

    test('endless mode result is a copy, not a reference to the input', () => {
      const pool = getCountryPool(sampleCountries, 'endless');
      pool.push({ name: 'Ghost', tier: 'easy' });
      assertEqual(sampleCountries.length, 4, 'input array should not be mutated');
    });

    test('empty country list returns empty pool', () => {
      assertEqual(getCountryPool([], 'easy').length, 0);
    });

    test('does not mutate the input array', () => {
      const copy = [...sampleCountries];
      getCountryPool(sampleCountries, 'easy');
      assertEqual(sampleCountries.length, copy.length);
    });

    suite('classifyCorrectGuess()');

    test('completion when streak equals pool size', () =>
      assertEqual(classifyCorrectGuess(5, 5), 'completion'));
    test('not completion when streak is less than pool size', () =>
      assertEqual(classifyCorrectGuess(4, 5), 'correct'));
    test('completion triggers in any mode (hard: 20/20)', () =>
      assertEqual(classifyCorrectGuess(20, 20), 'completion')); // not mode-gated
    test('completion triggers for any large pool (e.g. 129/129)', () =>
      assertEqual(classifyCorrectGuess(129, 129), 'completion'));
    test('milestone at multiples of 5', () =>
      assertEqual(classifyCorrectGuess(5, 100), 'milestone'));
    test('milestone at 10', () =>
      assertEqual(classifyCorrectGuess(10, 50), 'milestone'));
    test('correct for non-milestone non-completion streak', () =>
      assertEqual(classifyCorrectGuess(3, 100), 'correct'));
    test('correct at streak 1', () =>
      assertEqual(classifyCorrectGuess(1, 50), 'correct'));
    test('completion takes priority over milestone when pool size is multiple of 5', () =>
      assertEqual(classifyCorrectGuess(5, 5), 'completion')); // 5 % 5 === 0, but completion checked first

    // ── getEndlessWeights() ────────────────────────────────────────────────────

    suite('getEndlessWeights()');

    test('streak 0–20 → 100% easy', () => {
      for (const s of [0, 1, 20]) {
        const w = getEndlessWeights(s);
        assertEqual(w.easy, 1, `easy should be 1.0 at streak ${s}`);
        assertEqual(w.medium, 0); assertEqual(w.hard, 0); assertEqual(w.expert, 0);
      }
    });

    test('streak 21–40 → 100% medium', () => {
      for (const s of [21, 30, 40]) {
        const w = getEndlessWeights(s);
        assertEqual(w.medium, 1, `medium should be 1.0 at streak ${s}`);
        assertEqual(w.easy, 0); assertEqual(w.hard, 0); assertEqual(w.expert, 0);
      }
    });

    test('streak 41–60 → 100% hard', () => {
      for (const s of [41, 50, 60]) {
        const w = getEndlessWeights(s);
        assertEqual(w.hard, 1, `hard should be 1.0 at streak ${s}`);
        assertEqual(w.easy, 0); assertEqual(w.medium, 0); assertEqual(w.expert, 0);
      }
    });

    test('streak 61+ → 100% expert', () => {
      for (const s of [61, 100, 999]) {
        const w = getEndlessWeights(s);
        assertEqual(w.expert, 1, `expert should be 1.0 at streak ${s}`);
        assertEqual(w.easy, 0); assertEqual(w.medium, 0); assertEqual(w.hard, 0);
      }
    });

    test('each bracket weights sum to 1.0', () => {
      for (const streak of [10, 30, 50, 70]) {
        const w = getEndlessWeights(streak);
        const sum = w.easy + w.medium + w.hard + w.expert;
        assert(Math.abs(sum - 1.0) < 0.0001,
          `weights at streak ${streak} sum to ${sum}, expected 1.0`);
      }
    });

    // ── drawEndlessCountry() ───────────────────────────────────────────────────

    suite('drawEndlessCountry()');

    const endlessPool = [
      { id: 'e1', name: 'France',   tier: 'easy'   },
      { id: 'e2', name: 'Germany',  tier: 'easy'   },
      { id: 'm1', name: 'Albania',  tier: 'medium' },
      { id: 'm2', name: 'Georgia',  tier: 'medium' },
      { id: 'h1', name: 'Djibouti', tier: 'hard'   },
      { id: 'h2', name: 'Comoros',  tier: 'hard'   },
      { id: 'x1', name: 'Nauru',    tier: 'expert' },
      { id: 'x2', name: 'Tuvalu',   tier: 'expert' },
    ];

    test('returns a country object from the pool', () => {
      const result = drawEndlessCountry(endlessPool, 0, null);
      assert(result && typeof result.id === 'string', 'expected a country with an id');
      assert(endlessPool.some(c => c.id === result.id), 'result must be from the pool');
    });

    test('never returns the excluded country', () => {
      const exclude = endlessPool[0];
      for (let i = 0; i < 50; i++) {
        const result = drawEndlessCountry(endlessPool, 0, exclude);
        assert(result.id !== exclude.id, 'should never return the excluded country');
      }
    });

    test('works with null exclude (first draw)', () => {
      const result = drawEndlessCountry(endlessPool, 0, null);
      assert(result !== undefined && result !== null);
    });

    test('returns a country when only one country exists (no exclusion possible)', () => {
      const single = [{ id: 'only', name: 'Solo', tier: 'easy' }];
      const result = drawEndlessCountry(single, 0, single[0]);
      assert(result !== undefined, 'should return a country even when excluded is the only one');
    });

    test('at streak 31+ only draws from hard/expert (no easy in pool bias)', () => {
      // With easy weight 0 at streak 31, no easy countries should ever be returned
      // Replace pool with only easy countries to test the fallback weight redistribution
      const easyOnly = [
        { id: 'e1', name: 'France',  tier: 'easy' },
        { id: 'e2', name: 'Germany', tier: 'easy' },
      ];
      // With only easy countries and easy weight=0, effective weight is 0 for all → fallback
      // The fallback should still return a valid country
      const result = drawEndlessCountry(easyOnly, 31, null);
      assert(result !== undefined && result.tier === 'easy',
        'fallback should return a country when all weighted tiers are empty');
    });

    suite('drawEndlessCountry() — deterministic tier selection via Math.random mock');

    // Helper: temporarily replace Math.random with a fixed value
    function withMockRandom(value, fn) {
      const orig = Math.random;
      Math.random = () => value;
      try { return fn(); } finally { Math.random = orig; }
    }

    // Streak 0-20: 100% easy → any rand value draws easy
    test('streak 10 → always draws easy regardless of rand', () => {
      for (const rand of [0, 0.5, 0.9999]) {
        const result = withMockRandom(rand, () => drawEndlessCountry(endlessPool, 10, null));
        assertEqual(result.tier, 'easy', `expected easy at streak 10 with rand=${rand}`);
      }
    });

    // Streak 21-40: 100% medium → any rand value draws medium
    test('streak 30 → always draws medium regardless of rand', () => {
      for (const rand of [0, 0.5, 0.9999]) {
        const result = withMockRandom(rand, () => drawEndlessCountry(endlessPool, 30, null));
        assertEqual(result.tier, 'medium', `expected medium at streak 30 with rand=${rand}`);
      }
    });

    // Streak 41-60: 100% hard → any rand value draws hard
    test('streak 50 → always draws hard regardless of rand', () => {
      for (const rand of [0, 0.5, 0.9999]) {
        const result = withMockRandom(rand, () => drawEndlessCountry(endlessPool, 50, null));
        assertEqual(result.tier, 'hard', `expected hard at streak 50 with rand=${rand}`);
      }
    });

    // Streak 61+: 100% expert → any rand value draws expert
    test('streak 65 → always draws expert regardless of rand', () => {
      for (const rand of [0, 0.5, 0.9999]) {
        const result = withMockRandom(rand, () => drawEndlessCountry(endlessPool, 65, null));
        assertEqual(result.tier, 'expert', `expected expert at streak 65 with rand=${rand}`);
      }
    });

    // ── getActiveTier() ────────────────────────────────────────────────────────

    suite('getActiveTier() — non-endless modes always neutral');

    test('easy mode → always easy regardless of streak', () => {
      assertEqual(getActiveTier('easy', 0),   'easy');
      assertEqual(getActiveTier('easy', 999), 'easy');
    });

    test('medium mode → always easy (neutral outside endless)', () => {
      assertEqual(getActiveTier('medium', 0),   'easy');
      assertEqual(getActiveTier('medium', 999), 'easy');
    });

    test('hard mode → always easy (neutral outside endless)', () => {
      assertEqual(getActiveTier('hard', 0),   'easy');
      assertEqual(getActiveTier('hard', 999), 'easy');
    });

    suite('getActiveTier() — endless mode tier boundaries');

    test('streak 0 → easy', ()  => assertEqual(getActiveTier('endless', 0),  'easy'));
    test('streak 20 → easy (boundary)', () => assertEqual(getActiveTier('endless', 20), 'easy'));
    test('streak 21 → medium',          () => assertEqual(getActiveTier('endless', 21), 'medium'));
    test('streak 40 → medium (boundary)', () => assertEqual(getActiveTier('endless', 40), 'medium'));
    test('streak 41 → hard',            () => assertEqual(getActiveTier('endless', 41), 'hard'));
    test('streak 60 → hard (boundary)', () => assertEqual(getActiveTier('endless', 60), 'hard'));
    test('streak 61 → expert',          () => assertEqual(getActiveTier('endless', 61), 'expert'));
    test('streak 999 → expert',         () => assertEqual(getActiveTier('endless', 999), 'expert'));

    suite('ENDLESS_TIER_CUTOFFS — consistency with getEndlessWeights');

    test('at easy cutoff, weight brackets still give 100% easy', () => {
      assertEqual(getEndlessWeights(ENDLESS_TIER_CUTOFFS.easy).easy, 1);
    });

    test('at easy cutoff + 1, weight brackets give 100% medium', () => {
      assertEqual(getEndlessWeights(ENDLESS_TIER_CUTOFFS.easy + 1).medium, 1);
    });

    test('at medium cutoff, weight brackets still give 100% medium', () => {
      assertEqual(getEndlessWeights(ENDLESS_TIER_CUTOFFS.medium).medium, 1);
    });

    test('at medium cutoff + 1, weight brackets give 100% hard', () => {
      assertEqual(getEndlessWeights(ENDLESS_TIER_CUTOFFS.medium + 1).hard, 1);
    });

    test('at hard cutoff, weight brackets still give 100% hard', () => {
      assertEqual(getEndlessWeights(ENDLESS_TIER_CUTOFFS.hard).hard, 1);
    });

    test('at hard cutoff + 1, weight brackets give 100% expert', () => {
      assertEqual(getEndlessWeights(ENDLESS_TIER_CUTOFFS.hard + 1).expert, 1);
    });

    // ── loadCountries() — error paths (Issue 11) ──────────────────────────────

    suite('loadCountries() — error paths');

    await testAsync('throws friendly message on HTTP error (non-OK response)', async () => {
      const origFetch = globalThis.fetch;
      globalThis.fetch = async () => ({ ok: false, status: 500 });
      try {
        await loadCountries();
        throw new Error('expected loadCountries() to throw');
      } catch (err) {
        assert(
          err.message.includes('500'),
          `expected error to mention status 500, got: "${err.message}"`
        );
      } finally {
        globalThis.fetch = origFetch;
      }
    });

    await testAsync('throws friendly message when fetch times out (AbortError)', async () => {
      const origFetch = globalThis.fetch;
      globalThis.fetch = async () => {
        const err = new DOMException('The operation was aborted.', 'AbortError');
        throw err;
      };
      try {
        await loadCountries();
        throw new Error('expected loadCountries() to throw');
      } catch (err) {
        assert(
          err.message.toLowerCase().includes('timed out'),
          `expected timeout message, got: "${err.message}"`
        );
      } finally {
        globalThis.fetch = origFetch;
      }
    });

    await testAsync('propagates non-abort network errors unchanged', async () => {
      const origFetch = globalThis.fetch;
      const networkErr = new TypeError('Failed to fetch');
      globalThis.fetch = async () => { throw networkErr; };
      try {
        await loadCountries();
        throw new Error('expected loadCountries() to throw');
      } catch (err) {
        assert(err === networkErr, `expected the original error to propagate, got: "${err.message}"`);
      } finally {
        globalThis.fetch = origFetch;
      }
    });

    await testAsync('throws when response has no valid country data', async () => {
      const origFetch = globalThis.fetch;
      // Valid HTTP 200 but TopoJSON with no recognisable country IDs
      globalThis.fetch = async () => ({
        ok: true,
        json: async () => ({
          type: 'Topology',
          objects: { countries: { type: 'GeometryCollection', geometries: [] } },
          arcs: [],
        }),
      });
      try {
        await loadCountries();
        throw new Error('expected loadCountries() to throw');
      } catch (err) {
        assert(
          err.message.toLowerCase().includes('no country'),
          `expected "no country" message, got: "${err.message}"`
        );
      } finally {
        globalThis.fetch = origFetch;
      }
    });

    // ── escapeHtml() ──────────────────────────────────────────────────────────

    suite('escapeHtml()');

    test('escapes &', () => assertEqual(escapeHtml('a&b'), 'a&amp;b'));
    test('escapes <', () => assertEqual(escapeHtml('<div>'), '&lt;div&gt;'));
    test('escapes >', () => assertEqual(escapeHtml('a>b'), 'a&gt;b'));
    test('escapes double quote', () => assertEqual(escapeHtml('"hi"'), '&quot;hi&quot;'));
    test("escapes single quote", () => assertEqual(escapeHtml("it's"), "it&#39;s"));
    test('leaves plain text unchanged', () => assertEqual(escapeHtml('hello world'), 'hello world'));
    test('handles empty string', () => assertEqual(escapeHtml(''), ''));

    // ── storage.js — localStorage mock helper ─────────────────────────────────
    // Temporarily replace localStorage with an in-memory object for isolation.

    function withMockStorage(fn) {
      const store = {};
      const mock = {
        getItem:    key       => Object.prototype.hasOwnProperty.call(store, key) ? store[key] : null,
        setItem:    (key, val) => { store[key] = String(val); },
        removeItem: key       => { delete store[key]; },
      };
      const orig = globalThis.localStorage;
      Object.defineProperty(globalThis, 'localStorage', { value: mock, configurable: true });
      try {
        fn(mock, store);
      } finally {
        Object.defineProperty(globalThis, 'localStorage', { value: orig, configurable: true });
      }
    }

    suite('storage — getPlayerName / setPlayerName');

    test('getPlayerName() returns null when not set', () =>
      withMockStorage(() => {
        assertEqual(getPlayerName(), null);
      }));

    test('setPlayerName / getPlayerName round-trip', () =>
      withMockStorage(() => {
        setPlayerName('alice');
        assertEqual(getPlayerName(), 'alice');
      }));

    suite('storage — addScore');

    test('addScore is a no-op when streak < 1 (streak 0)', () =>
      withMockStorage((_, store) => {
        addScore({ name: 'bob', streak: 0, mode: 'easy' });
        assert(!Object.prototype.hasOwnProperty.call(store, SCORES_KEY), 'expected no entry in store');
      }));

    test('addScore is a no-op when streak < 1 (streak -1)', () =>
      withMockStorage((_, store) => {
        addScore({ name: 'bob', streak: -1, mode: 'easy' });
        assert(!Object.prototype.hasOwnProperty.call(store, SCORES_KEY), 'expected no entry in store');
      }));

    test('addScore stores correct shape { name, streak, mode, timestamp }', () =>
      withMockStorage(() => {
        const before = Date.now();
        addScore({ name: 'alice', streak: 5, mode: 'hard' });
        const after = Date.now();
        const scores = _loadScores();
        assertEqual(scores.length, 1);
        assertEqual(scores[0].name, 'alice');
        assertEqual(scores[0].streak, 5);
        assertEqual(scores[0].mode, 'hard');
        assert(scores[0].timestamp >= before && scores[0].timestamp <= after, 'timestamp out of range');
      }));

    test('addScore trims to MAX_SCORES after inserting 101 entries', () =>
      withMockStorage(() => {
        for (let i = 0; i < MAX_SCORES + 1; i++) {
          addScore({ name: 'player', streak: i + 1, mode: 'easy' });
        }
        const scores = _loadScores();
        assert(scores.length <= MAX_SCORES, `expected <= ${MAX_SCORES}, got ${scores.length}`);
      }));

    suite('storage — getLeaderboard / sorting');

    test('getLeaderboard returns empty array when nothing stored', () =>
      withMockStorage(() => {
        assertEqual(getLeaderboard().length, 0);
      }));

    test('getLeaderboard sorts endless before hard before medium before easy', () =>
      withMockStorage(() => {
        addScore({ name: 'a', streak: 1, mode: 'easy'    });
        addScore({ name: 'b', streak: 1, mode: 'medium'  });
        addScore({ name: 'c', streak: 1, mode: 'hard'    });
        addScore({ name: 'd', streak: 1, mode: 'endless' });
        const lb = getLeaderboard();
        assertEqual(lb[0].mode, 'endless');
        assertEqual(lb[1].mode, 'hard');
        assertEqual(lb[2].mode, 'medium');
        assertEqual(lb[3].mode, 'easy');
      }));

    test('getLeaderboard sorts by streak within the same mode', () =>
      withMockStorage(() => {
        addScore({ name: 'a', streak: 3, mode: 'hard' });
        addScore({ name: 'b', streak: 7, mode: 'hard' });
        addScore({ name: 'c', streak: 1, mode: 'hard' });
        const lb = getLeaderboard();
        assertEqual(lb[0].streak, 7);
        assertEqual(lb[1].streak, 3);
        assertEqual(lb[2].streak, 1);
      }));

    suite('storage — _loadScores corrupt data');

    test('_loadScores returns [] on corrupt JSON', () =>
      withMockStorage((_, store) => {
        store[SCORES_KEY] = '{ not valid json [[[';
        assertEqual(_loadScores().length, 0);
      }));

    test('_loadScores returns [] when stored value is non-array JSON', () =>
      withMockStorage((_, store) => {
        store[SCORES_KEY] = JSON.stringify({ oops: true });
        assertEqual(_loadScores().length, 0);
      }));

    // ── Summary ────────────────────────────────────────────────────────────────

    const total = passed + failed;
    sumEl.innerHTML = `
      <strong>${total} test${total !== 1 ? 's' : ''}:
        <span class="${failed ? 'fail' : 'pass'}">${passed} passed</span>
        ${failed ? `, <span class="fail">${failed} failed</span>` : ''}
      </strong>
    `;
  </script>
</body>
</html>
